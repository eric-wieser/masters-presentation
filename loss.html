<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Gaussian</title>
  <script src="build/mathbox-bundle.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/q.js/2.0.3/q.js"></script>
  <script src="./Trajectory.js"></script>
  <script src="./data.json"></script>
  <script src="./matlabcolors.js"></script>
  <link rel="stylesheet" href="build/mathbox.css">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
</head>
<body>
  <script type="application/glsl" id="lerp-shader">
    // External sources
    uniform float f;

    // Source being resampled
    vec4 vertexShader(vec4 xyzw, inout vec4 stpq) {
      return vec4(xyzw.x, (1.0-f)*xyzw.y + f*xyzw.z, 0, 0);
    }
  </script>
  <script type="application/glsl" id="lerp2-shader">
  // Two external sources
  vec4 getSampleA(vec4 xyzw);
  vec4 getSampleB(vec4 xyzw);

  // Original resampled source (unused)
  vec4 getSampleDummy(vec4 xyzw);

  // Resample shader
  vec4 getSample(vec4 xyzw) {
    // Get two floats and multiply them
    vec4 a = getSampleA(xyzw);
    vec4 b = getSampleB(xyzw);

    // Return as y value
    return vec4(0.0, a * b, 0.0, 0.0);
  }
  </script>

  <script>
    var mathbox = mathBox({
      plugins: ['core', 'controls', 'cursor', 'mathbox'],
      controls: {
        // Orbit controls, i.e. Euler angles, with gimbal lock
        // klass: THREE.OrbitControls,

        // Trackball controls, i.e. Free quaternion rotation
        klass: THREE.TrackballControls,
      },
    });
    var three = mathbox.three;

    var time = 0;
    three.on('update', function () {
      var clock = three.Time.clock;
      time = clock / 4;
    });

    dt = 0.1;

    three.renderer.setClearColor(new THREE.Color(0xFFFFFF), 1.0);

    if (window == top)
      window.onkeydown = function (e) {
        switch (e.keyCode) {
          case 37:
          case 38:
            present.set('index', present.get('index') - 1);
            break;
          case 39:
          case 40:
            present.set('index', present.get('index') + 1);
            break;
        }
        //console.log(present.get('index'));
      }

    // setInterval(function () {
    //   present.set('index', (present.get('index') + 1) % (present.get('length') + 1));
    // }, 2000);

    var view = mathbox.cartesian({
      id: 'the-view',
      range: [[0, 50], [0,2.5], [0, 1]],
      scale: [2, 1, 0.5],
    });

    var present = view.present({
      index: 1
    })


    var data_obj = [17, 45, 90].map(function(angle) {
      var name_c = 'sim_cost_' + angle;
      var name_nc = 'sim_nocost_' + angle;
      return {
        a: angle,
        c: rollout_data[name_c],
        nc: rollout_data[name_nc]
      }
    });
    var ang_cols = {
      17: colors.yellow,
      45: colors.orange,
      90: colors.blue
    };

    data_obj.forEach(function(d) {
      var a = view.array({
        expr: function(emit, i) {
          emit(i, d.nc.lengths[i], d.c.lengths[i]);
        },
        live: false,
        width: 50,
        channels: 3,
        id: 'sim_' + d.a
      });
    });

    data_obj.forEach(function(d) {
      view.voxel({
        width: 40,    // iterations
        height: 51,   // timesteps
        depth: 2,     // cost/nocost
        items: 3,     // mean, bounds
        channels: 1,
        expr: function(emit, i, j, k) {
          var prop = k == 0 ? 'nc' : 'c';
          var g = d[prop].loss_pred[i][j];
          emit(g.m);
          emit(g.m + 2*Math.sqrt(g.s));
          emit(g.m - 2*Math.sqrt(g.s));
        },
        id: 'losses_' + d.a
      });
    });

    var slides = present.slide({steps: 10});


    slides
      .camera({proxy: false, up: [0, 0.001, 1], lookAt: [0, 0, 0]})
      .step({
        stops: [0, 0, 0, 0, 1, 2],
        duration: 0.5,
        script: {
          '0': { position: [0, 0, 2.5]},
          '1': { position: [0, -1, 4.5]},
          '2': { position: [3, -2, 1.5]},
        }
      })

    // show grid and 90 data
    slides
      .slide({from: 0, to: 10})
        .reveal()
          // create the axes
          .axis({ axis: 'x'})
          .axis({ axis: 'y' })
          .grid({ axes: 'xy' })

          // tick labels
          .scale({
            divide: 5,
            origin: [0,0,0,0],
            axis: "x",
          })
          .ticks()
          .format().label()
          .scale({
            divide: 5,
            origin: [0,0,0,0],
            axis: "y",
          })
          .format({expr: function(x) { return x.toFixed(1); }}).label({offset: [-20, 0]})

          // axis labels
          .array({ data: [[25, 0, 0]], channels: 3 })
          .text({ data: ['Iteration']})
          .label({offset: [0, -40]})
          .array({ data: [[0, 1.25, 0]], channels: 3 })
          .text({ data: ['Time upright / s']})
          .label({offset: [-40, 0]})

          // plot the 90 data
          .shader({ code: "#lerp-shader"})
          .step({ script: [
            {props: {f: 0}},
            {props: {f: 0}},
            {props: {f: 0}},
            {props: {f: 1}},
            {props: {f: 0}}
          ]})
          .vertex()
            .line({
              points: '#sim_90',
              color: colors.blue,
              size: 15
            })

    // plot the 45 data
    slides
      .slide({from: 1, to: 10})
        .reveal()
          .shader({ code: "#lerp-shader"})
          .step({ script: [
            {props: {f: 0}},
            {props: {f: 0}},
            {props: {f: 1}},
            {props: {f: 0}}
          ]})
          .vertex()
            .line({
              points: '#sim_17',
              color: colors.yellow,
              size: 15
            })

    // plot the 17 data
    slides
      .slide({from: 2, to: 10})
        .reveal()
          // plot the 45 data
          .shader({ code: "#lerp-shader"})
          .step({ script: [
            {props: {f: 0}},
            {props: {f: 1}},
            {props: {f: 0}}
          ]})
          .vertex()
            .line({
              points: '#sim_45',
              color: colors.orange,
              size: 15
            })


    // add 3d axis
    slides
      .slide({from: 4, to: 10})
        .axis({axis: 'z'})
        .grid({axes: 'zy'})
        .grid({axes: 'zx', origin: [0, 2.5, 0, 0]})
        .scale({
          divide: 2,
          origin: [0,0,0,0],
          axis: "z",
        })
        .ticks()
        .format().label({offset: [-20, 0]})
        .array({ data: [[0, 0, 0.5]], channels: 3 })
        .text({ data: ['Loss']})
        .label({offset: [-100, 0]})
    ;
    [17, 45, 90].forEach(function(a, i) {
      var c = ang_cols[a];
      slides
        .slide({from: 5+i, to: 5+i+1})
          .swizzle({source: '#losses_' + a, order: 'zyxw'})
          .spread({
            alignWidth:  'first',
            alignHeight: 'first',
            unit: 'absolute',
            width:  [1, 0, 0],
            height: [0, 0.05, 0],
          })
          .slice({depth: [0, 1]}) // no cost
          .transform({position: [10, 0, 0]})
            // mean
            .slice({items: [0, 1]})
            .transpose({order: 'ywzx'})
            .line({color: c})

            //bounds
            .slice({source: '<<', items: [1, 3]})
            .transpose({order: 'ywzx'})
            // .surface({color: c, opacity: 0.25})
            .line({color: c, opacity: 0.75})
          .end()
    });

  </script>
</body>
</html>
